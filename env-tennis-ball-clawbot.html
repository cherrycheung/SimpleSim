<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Robot Sim</title>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.161.0/build/three.module.js",
          "three/examples/jsm/": "https://unpkg.com/three@0.161.0/examples/jsm/",
          "three/addons/": "https://unpkg.com/three@0.161.0/examples/jsm/"
        }
      }
    </script>
    <script src="https://unpkg.com/ammo.js@0.0.10/ammo.js"></script>
    <script type="module" src="/static/js/physics.js"></script>
    <script type="module" src="/static/js/lan.js"></script>
    <!-- <script type="text/javascript" src="/static/js/ammo.js"></script> -->


    <style type="text/css">
      * {
        margin: 0;
        padding: 0;
      }
    </style>


<script id="post-vert" type="x-shader/x-vertex">
  varying vec2 vUv;

  void main() {
    vUv = uv;
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
</script>
<script id="post-frag" type="x-shader/x-fragment">
  #include <packing>

  varying vec2 vUv;
  uniform sampler2D tDiffuse;
  uniform sampler2D tDepth;
  uniform float cameraNear;
  uniform float cameraFar;


  float readDepth( sampler2D depthSampler, vec2 coord ) {
    float fragCoordZ = texture2D( depthSampler, coord ).x;
    float viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );
    return viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );
  }

  void main() {
    //vec3 diffuse = texture2D( tDiffuse, vUv ).rgb;
    float depth = readDepth( tDepth, vUv );
    float mpost250;
    float mm250 = modf(depth * 256.0f, mpost250);

    gl_FragColor.rgb = vec3( mm250, mpost250 / 256.0f, 0 );
    //gl_FragColor.a = 1.0;
  }
</script>

  </head>
  <body>
    <script type="module">
      import * as THREE from 'three';
      import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';
      import { ColladaLoader } from 'three/examples/jsm/loaders/ColladaLoader.js';
      import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
      import AmmoPhysics from '/static/js/physics.js';
      import WSConnection from '/static/js/lan.js';
      import { Field } from '/static/js/field.js';

      // Create a scene + physics
      const scene = new THREE.Scene();
      const physx = new AmmoPhysics(new THREE.Clock(), { angularDamping: 0.99 });
      const colGroup = {
        env: 1,
        robot: 2,
        effector: 4,
        object: 8,
        arm1: 16,
        arm2: 32
      };
      const everyCollideGroup = 0xFF;

      // Create a camera
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50);
      camera.position.set(0, 3, 5);
      camera.lookAt(0, 0, 0);

      // Create a renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.shadowMap.enabled = true;
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setClearColor(0x80c0e0);
      document.body.appendChild(renderer.domElement);

      // Setup lights
      const dirLight = new THREE.DirectionalLight();
      dirLight.position.set(15, 50, -15);
      dirLight.castShadow = true;
      dirLight.shadow.camera.left = -100;
      dirLight.shadow.camera.right = 100;
      dirLight.shadow.camera.bottom = -100;
      dirLight.shadow.camera.top = 100;
      dirLight.shadow.camera.near = 0.1;
      dirLight.shadow.camera.far = 100;
      scene.add(dirLight);

      const dirLight2 = new THREE.DirectionalLight();
      dirLight2.position.set(-15, 50, 15);
      dirLight2.castShadow = true;
      dirLight2.shadow.camera.left = -100;
      dirLight2.shadow.camera.right = 100;
      dirLight2.shadow.camera.bottom = -100;
      dirLight2.shadow.camera.top = 100;
      dirLight2.shadow.camera.near = 0.1;
      dirLight2.shadow.camera.far = 100;
      scene.add(dirLight2);

      const amLight = new THREE.AmbientLight();
      amLight.intensity = 0.1;
      scene.add(amLight);

      // Create controller for viewing
      const controller = new OrbitControls(camera, renderer.domElement);

      const field = new Field();
      field.initMeshes(physx);
      scene.add(field);

      //// ROBOT
      const in2m = (x) => x * 0.0254;

      // const loader = new GLTFLoader();
      // const robot_url = '/static/models/Robot.gltf';
      // loader.load(robot_url, (mesh) => {
      // });

      const chassisMass = 5.0;
      const chassisWidth = in2m(10);
      const chassisHeight = in2m(1);
      const chassisLength = in2m(10);
      
      const metalMaterial = new THREE.MeshLambertMaterial({color: 0xc0c0c0});
      const chassisGeometry = new THREE.BoxGeometry(
        chassisWidth, chassisHeight, chassisLength);
      const chassis = new THREE.Mesh(chassisGeometry, metalMaterial);
      chassis.position.set(0, in2m(2.25), 0); // this is the middle of the metal bar
      chassis.castShadow = true;
      chassis.receiveShadow = true;
      scene.add(chassis);

      const standGeometry = new THREE.BoxGeometry(in2m(3), in2m(7.5), in2m(1));
      const stand = new THREE.Mesh(standGeometry, metalMaterial);
      stand.castShadow = true;
      stand.receiveShadow = true;
      stand.position.set(0, in2m(.5 + 7.5 / 2), in2m(4.5)); // relative to the center of the chassis
      chassis.add(stand);

      // let's add it to the physics world manually since there are alot of custom stuff
      const fullChassisHeight = in2m(2.25 + .5 + 7.5); // including wheel height
      const transform = new Ammo.btTransform();
      transform.setIdentity();
      physx.p_.setValue(
        chassis.position.x,
        fullChassisHeight / 2,
        chassis.position.z);
      transform.setOrigin(physx.p_);
      physx.q_.setValue(
        chassis.quaternion.x,
        chassis.quaternion.y,
        chassis.quaternion.z,
        chassis.quaternion.w);
      transform.setRotation(physx.q_);
      const motionState = new Ammo.btDefaultMotionState(transform);
      const collisionShape = new Ammo.btBoxShape(new Ammo.btVector3(
        chassisWidth / 2, fullChassisHeight / 2, chassisLength / 2));
      collisionShape.setMargin(0.05);
      physx.p_.setValue(0, 0, 0); // local inertia
      collisionShape.calculateLocalInertia(chassisMass, physx.p_);
      const rigidbodyInfo = new Ammo.btRigidBodyConstructionInfo(
        chassisMass, motionState, collisionShape, physx.p_);
      const chassisRB = new Ammo.btRigidBody(rigidbodyInfo);
      chassisRB.setActivationState(4); // shutoff deactivation
      physx.world.addRigidBody(chassisRB, colGroup.robot, colGroup.env);
      chassis.userData.rigidbody = chassisRB;
      chassis.userData.options = {
        mass: chassisMass,
        collideGroup: colGroup.robot,
        collideWith: colGroup.env
      };

      const FRONT_LEFT = 0;
      const FRONT_RIGHT = 1;
      const BACK_LEFT = 2;
      const BACK_RIGHT = 3;
      const wheelAxisX = in2m(5);
      const wheelAxisY = in2m(-.25);
      const wheelAxisZ = in2m(4.25);
      const wheelRadius = in2m(2);
      const wheelWidth = in2m(0.88);

      const wheelGeometry = new THREE.CylinderGeometry(wheelRadius, wheelRadius, wheelWidth);
      const wheelMaterial = new THREE.MeshLambertMaterial({color: 0x00aa00});
      const wheelMeshes = [];

      for (let i = 0; i < 4; i++) {
        const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
        wheel.castShadow = true;
        wheel.receiveShadow = true;
        wheelMeshes.push(wheel);
        wheel.rotateZ(Math.PI / 2);
        scene.add(wheel);
      }

      wheelMeshes[FRONT_LEFT ].position.set(-wheelAxisX, wheelAxisY,-wheelAxisZ);
      wheelMeshes[FRONT_RIGHT].position.set( wheelAxisX, wheelAxisY,-wheelAxisZ);
      wheelMeshes[BACK_LEFT  ].position.set(-wheelAxisX, wheelAxisY, wheelAxisZ);
      wheelMeshes[BACK_RIGHT ].position.set( wheelAxisX, wheelAxisY, wheelAxisZ);

      for (const wheel of wheelMeshes) {
        chassis.add(wheel);
      }

      let leftAction = 0;
      let rightAction = 0;

      // add arm
      const armGeometry = new THREE.BoxGeometry(in2m(1), in2m(0.5), in2m(12.5));
      const arm1 = new THREE.Mesh(armGeometry, metalMaterial);
      arm1.castShadow = true;
      arm1.receiveShadow = true;
      arm1.position.set(0, fullChassisHeight - in2m(.5), in2m(-1));
      scene.add(arm1);
      physx.add(arm1, {
        mass: 0.05,
        collideGroup: colGroup.arm1,
        collideWith: colGroup.env | colGroup.arm2
      });
      const arm2 = new THREE.Mesh(armGeometry, metalMaterial);
      arm2.castShadow = true;
      arm2.receiveShadow = true;
      arm2.position.set(0, fullChassisHeight - in2m(2.5), in2m(-1));
      scene.add(arm2);
      physx.add(arm2, {
        mass: 0.05,
        collideGroup: colGroup.arm2,
        collideWith: colGroup.env | colGroup.arm1
      });

      const clawBaseGeometry = new THREE.BoxGeometry(in2m(1.5), in2m(2.5), in2m(2.25));
      const clawBase = new THREE.Mesh(clawBaseGeometry, metalMaterial);
      clawBase.castShadow = true;
      clawBase.receiveShadow = true;
      clawBase.position.set(0, fullChassisHeight - in2m(1.5), in2m(-7 - (2.25 / 2 - .25)));
      scene.add(clawBase);
      physx.add(clawBase, {
        mass: 0.05,
        collideGroup: colGroup.effector,
        collideWith: colGroup.env | colGroup.object
      });

      const chassis_arm1 = physx.hinge({
        mesh: chassis,
        xyz: [0, fullChassisHeight / 2 - in2m(.5), in2m(4.5)],
        axis: [1, 0, 0]
      }, {
        mesh: arm1,
        xyz: [0, 0, in2m(5.5)],
        axis: [1, 0, 0]
      });
      const arm1_effector = physx.hinge({
        mesh: arm1,
        xyz: [0, 0, in2m(-6)],
        axis: [1, 0, 0]
      }, {
        mesh: clawBase,
        xyz: [0, in2m(1), in2m(2.25 / 2 - .25)],
        axis: [1, 0, 0]
      });
      const chassis_arm2 = physx.hinge({
        mesh: chassis,
        xyz: [0, fullChassisHeight / 2 - in2m(2.5), in2m(4.5)],
        axis: [1, 0, 0]
      }, {
        mesh: arm2,
        xyz: [0, 0, in2m(5.5)],
        axis: [1, 0, 0]
      });
      const arm2_effector = physx.hinge({
        mesh: arm2,
        xyz: [0, 0, in2m(-6)],
        axis: [1, 0, 0]
      }, {
        mesh: clawBase,
        xyz: [0, in2m(-1), in2m(2.25 / 2 - .25)],
        axis: [1, 0, 0]
      });
      chassis_arm2.joint.enableAngularMotor(true, 0, 3);
      let armAction = 0;

      const robotCamera = new THREE.PerspectiveCamera(75, 640 / 360, 0.1, 50);
      robotCamera.position.set(0, in2m(2.5), in2m(4.5));
      robotCamera.lookAt(0, in2m(2.5), -1); // look forward
      arm1.add(robotCamera);

      // load in a basic sphere as our "object"
      const ballGeometry = new THREE.SphereGeometry(in2m(1.28));
      const ballMaterial = new THREE.MeshLambertMaterial({color: 0x10ff00});
      const ball = new THREE.Mesh(ballGeometry, ballMaterial);
      ball.position.set(0, in2m(1.28), 0);
      scene.add(ball);
      physx.add(ball, {
        mass: 0.03,
        collideGroup: colGroup.object,
        collideWith: colGroup.env | colGroup.effector
      });
      physx.get(ball).setFriction(2);
      physx.get(ball).setRollingFriction(5);

      //// Animation loop
      const p = new THREE.Vector3(0, 0, 0);
      const q = new THREE.Quaternion(0, 0, 0, 1);
      const v = new THREE.Vector3(0, 0, 0);
      const heading = new THREE.Euler();
      const pitch = new THREE.Euler();
      const rpm = 100;
      const omega = rpm * 2 * Math.PI / 60;
      const meters_psec = omega * in2m(2);
      const linearCoeff = meters_psec;
      const angularCoeff = meters_psec / in2m(10);

      // Create websocket connection
      const connection = new WSConnection(9999, 640, 360, 0.1, 60);

      function calcReward() {
        heading.setFromQuaternion(chassis.quaternion, 'YZX');
        const distance = clawBase.position.distanceTo(ball.position);
        const pq_theta = Math.atan2(clawBase.position.x - ball.position.x, clawBase.position.z - ball.position.z);
        let dtheta = pq_theta - heading.y;
        while (dtheta > Math.PI) dtheta -= 2 * Math.PI; 
        while (dtheta < -Math.PI) dtheta += 2 * Math.PI;
        pitch.setFromQuaternion(arm1.quaternion, 'YZX');
        const reward = 1 - distance - Math.abs(dtheta) / Math.PI;

        connection.setObservationReward([
          chassis.position.x,
          -chassis.position.z,
          heading.y,
          pitch.x,
          physx.get(arm1).getAngularVelocity().x(),
          ball.position.x,
          -ball.position.z,
          distance,
          dtheta,
          0
        ], reward);
        connection.render(scene, robotCamera);
      }

      connection.onreset = () => {
        chassis.position.set(Math.random() * in2m(72) - in2m(36), in2m(2.25), Math.random() * in2m(72) - in2m(36));
        physx.T_.setIdentity();
        physx.p_.setValue(chassis.position.x, fullChassisHeight / 2, chassis.position.z);
        physx.T_.setOrigin(physx.p_);
        physx.q_.setValue(chassis.quaternion.x, chassis.quaternion.y, chassis.quaternion.z, chassis.quaternion.w);
        physx.T_.setRotation(physx.q_);
        physx.get(chassis).setWorldTransform(physx.T_);
        physx.get(chassis).getMotionState().setWorldTransform(physx.T_);
        physx.p_.setValue(0, 0, 0);
        physx.get(chassis).setLinearVelocity(physx.p_);
        physx.get(chassis).setAngularVelocity(physx.p_);

        p.set(0, fullChassisHeight - in2m(.5) - in2m(2.25), in2m(-1));
        p.applyQuaternion(chassis.quaternion);
        p.add(chassis.position);
        arm1.position.set(p.x, p.y, p.z);
        p.set(0, fullChassisHeight - in2m(2.5) - in2m(2.25), in2m(-1));
        p.applyQuaternion(chassis.quaternion);
        p.add(chassis.position);
        arm2.position.set(p.x, p.y, p.z);
        p.set(0, fullChassisHeight - in2m(1.5) - in2m(2.25), in2m(-7 - (2.25 / 2 - .25)));
        p.applyQuaternion(chassis.quaternion);
        p.add(chassis.position);
        clawBase.position.set(p.x, p.y, p.z);

        ball.position.set(Math.random() * in2m(140) - in2m(70), in2m(1.28), Math.random() * in2m(140) - in2m(70));
        console.log("Reset the world, new ball position:", ball.position);

        physx.reset();
        calcReward();
      };

      connection.onstep = (action) => {
        leftAction = action[0];
        rightAction = -action[9];
        armAction = action[1];

        pitch.setFromQuaternion(arm1.quaternion, 'YZX');
        
        if (pitch.x <= -0.7 && armAction < 0) {
          armAction = 0;
        } else if (pitch.x >= 0.6 && armAction > 0.1) {
          armAction = 0.1;
        } else if (pitch.x >= 0.55 && armAction > 0.5) {
          armAction = 0.5;
        }

        physx.getTransform(chassis, p, q);
        v.set(0, 0, linearCoeff * -(leftAction + rightAction) / 2);
        v.applyQuaternion(q);
        physx.p_.setValue(v.x, v.y, v.z);
        physx.get(chassis).setLinearVelocity(physx.p_);
        physx.p_.setValue(0, angularCoeff * (rightAction - leftAction), 0);
        physx.get(chassis).setAngularVelocity(physx.p_);

        const dt = physx.step();
        physx.getTransform(chassis, p, q);
        chassis.position.set(p.x, p.y - fullChassisHeight / 2 + in2m(2.25), p.z);
        chassis.quaternion.set(q.x, q.y, q.z, q.w);
        chassis_arm2.joint.enableAngularMotor(true, armAction * 1.5, 3);

        calcReward();
      };

      function render() {
        renderer.render(scene, camera);
      }
      renderer.setAnimationLoop(render);

    </script>
  </body>
</html>
